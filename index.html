<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/flowbite/2.3.0/flowbite.min.css"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/flowbite/2.3.0/flowbite.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="style.css" />
    <script src="prism.js"></script>
    <link rel="stylesheet" href="prism.css">
    <script src="navbar.js" defer></script>
    <title>Document</title>
  </head>
  <body class="bg-stone-900 text-stone-100 overflow-x-hidden">
    <!-- navbar ---------------------------------------------------------------->
    <nav
      class="bg-transparent border-b border-stone-600/80 fixed top-0 w-full z-20 transition-all"
    >
      <div
        class="max-w-screen-xl flex flex-wrap items-center justify-end md:justify-between mx-auto p-4"
      >
        <div class="flex md:order-2 space-x-3 rtl:space-x-reverse">
          <!-- <button
            type="button"
            class="text-white bg-stone-700 hover:bg-stone-600 focus:ring-4 focus:outline-none focus:ring-orange-300 font-medium rounded-sm text-sm px-4 py-2 text-center"
          >
            Github
          </button> -->
          <a href="build.apk" download="build.apk"><button
            type="button"
            class="text-white bg-orange-600 hover:bg-orange-700 focus:ring-4 focus:outline-none focus:ring-orange-300 font-medium rounded-sm text-sm px-4 py-2 text-center"
          >
            Télécharger APK
          </button></a>
          
          <button
            data-collapse-toggle="navbar-cta"
            type="button"
            class="inline-flex items-center p-2 w-10 h-10 justify-center text-sm text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200"
            aria-controls="navbar-cta"
            aria-expanded="false"
          >
            <span class="sr-only">Open main menu</span>
            <svg
              class="w-5 h-5"
              aria-hidden="true"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 17 14"
            >
              <path
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M1 1h15M1 7h15M1 13h15"
              />
            </svg>
          </button>
        </div>
        <div
          class="items-center justify-between hidden w-full md:flex md:w-auto md:order-1"
          id="navbar-cta"
        >
          <ul
            class="flex flex-col font-medium p-4 md:p-0 mt-4 border border-gray-100 rounded-lg text-white md:space-x-8 rtl:space-x-reverse md:flex-row md:mt-0 md:border-0"
          >
            <li>
              <a
                href="#home"
                class="block py-2 px-3 md:p-0 rounded hover:bg-gray-100 md:hover:bg-transparent md:hover:text-orange-600 text-orange-600"
                >Accueil</a
              >
            </li>
            <li>
              <a
                href="#demo"
                class="block py-2 px-3 md:p-0 rounded hover:bg-gray-100 md:hover:bg-transparent md:hover:text-orange-600"
                >Démo</a
              >
            </li>
            <li>
              <a
                href="#code"
                class="block py-2 px-3 md:p-0 rounded hover:bg-gray-100 md:hover:bg-transparent md:hover:text-orange-600"
                >Code</a
              >
            </li>
            <li>
              <a
                href="#unity"
                class="block py-2 px-3 md:p-0 rounded hover:bg-gray-100 md:hover:bg-transparent md:hover:text-orange-600"
                >Unity</a
              >
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <!-- navbar ---------------------------------------------------------------->

    <!-- hero ---------------------------------------------------------------->
    <section id="home"
      class="w-full px-6 py-16 mx-auto text-center h-screen grid items-center bg-[url('/bg.jpg')] bg-cover bg-fixed bg-center bg-no-repeat"
    >
      <div
        class="absolute top-0 left-0 backdrop-brightness-[35%] w-full h-full z-0"
      ></div>
      <div class="max-w-lg mx-auto relative z-10">
        <h1 class="text-5xl md:text-[130px] leading-none customfont">wr201</h1>
        <h1
          class="font-semibold text-orange-500 lg:text-xl leading-none uppercase"
        >
          Pourrez-vous vous échapper de la salle ?
        </h1>
        <p class="mt-6 text-lg text-stone-300">
          Voici le rendu de notre projet d'escape-game d'une salle de l'IUT,
          nous avons choisi la salle 201 avec un style post apocalyptic car
          c'est bientôt la fin du monde.
        </p>
      </div>
      <p class="absolute text-stone-400 bottom-4 right-4">Nathan Deuil | Robin Lanfranchi | Killian David</p>
    </section>
    <!-- hero ---------------------------------------------------------------->
    <!-- demo ---------------------------------------------------------------->
    <section id="demo" class="bg-orange-600">
      <div class="w-full grid grid-cols-2 gap-x-8 mx-auto p-4 max-w-screen-xl py-12 content-center">
        <div>
          <h3 class="md:text-4xl leading-none customfont mb-4">demo du jeu</h3>
          <p>Dans un premier temps, nous vous conseillons de ramasser la lampe torche par terre pour mieux voir à travers le brouillard. Ensuite, il faut trouver la clé pour déverrouiller la porte et pouvoir accéder à l'autre salle. La clé se trouve dans le dernier tiroir du meuble. Une fois cette dernière en main, il faut l'insérer dans la serrure de la porte puis tourner la poignée et tirer la porte. Dans la seconde partie de la salle, il y a une fuite de gaz qui vous empêche d'aller dans le coin. Il vous faut trouver un moyen de couper le gaz. Sur votre gauche, il y a une vanne qui permet de couper le gaz. Une qu'il est coupé, vous pouvez accéder à l'angle de la pièce dans lequel vous trouverez un buzzer qui permet d'appeler un hélicoptère. Attendez que l'hélicoptère vienne vous chercher pour gagner la partie.</p>
        </div>
        <iframe width="560" height="315" src="https://www.youtube.com/embed/wvMCbVaJbF4?si=6YZlsLbyVPd0Cc-g" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
      </div>
    </section>
    <!-- demo ---------------------------------------------------------------->
    <section id="code" >
      <div class="w-full min-h-screen grid grid-cols-2 gap-x-8 mx-auto p-4 max-w-screen-xl py-12">
      <div class="grow sticky top-24 h-fit w-full">
        <h3 class="md:text-4xl leading-none customfont text-orange-600">lampe torche</h3>
        <p class="mt-4">La lampe torche est un "must have" dans une situation post apocalyptic, cet incontournable est disponible en tant que gadget dans notre escape game. Elle permet à l'utilisateur de s'orienter et de trouver les objets nécessaires plus facilement !</p>
        <img src="flash-light.png" alt="" class="rounded mt-2">
      </div>
      <div class="grow w-full">
        <pre>
          <code class="language-clike">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class FlashlightBehaviour : MonoBehaviour
{
    [SerializeField] GameObject _flashlightLightOB;
    private bool _isFlashlightTurnedON;
    // Start is called before the first frame update
    void Start()
    {
        _isFlashlightTurnedON = true;
        TurnOnOrOffFlashlightLight(_isFlashlightTurnedON);
    }

    public void ActivateFlashlight()
    {
        _isFlashlightTurnedON = !_isFlashlightTurnedON;
        TurnOnOrOffFlashlightLight(_isFlashlightTurnedON);
    }

    void TurnOnOrOffFlashlightLight(bool lightStatus)
    {
        _flashlightLightOB.SetActive(lightStatus);
    }
}            
          </code>
      </div>
    </div>
    <div class="w-full min-h-screen grid grid-cols-2 gap-x-8 mx-auto p-4 max-w-screen-xl py-12">
      <div class="grow sticky top-24 h-fit w-full">
        <h3 class="md:text-4xl leading-none customfont text-orange-600">la vanne</h3>
        <p class="mt-4">Cet élément permet de couper l'arrivé du gaz qui vous empêchera de progresser dans la suite de la salle.</p>
        <img src="wheel.png" alt="" class="rounded mt-2">
      </div>
      <div class="grow w-full">
        <pre>
          <code class="language-clike">
using System;
using UnityEngine.Events;
using UnityEngine.XR.Interaction.Toolkit;

namespace UnityEngine.XR.Content.Interaction
{
    /// <summary>
    /// An interactable knob that follows the rotation of the interactor
    /// </summary>
    public class XRKnob : XRBaseInteractable
    {
        const float k_ModeSwitchDeadZone = 0.1f; // Prevents rapid switching between the different rotation tracking modes

        /// <summary>
        /// Helper class used to track rotations that can go beyond 180 degrees while minimizing accumulation error
        /// </summary>
        struct TrackedRotation
        {
            /// <summary>
            /// The anchor rotation we calculate an offset from
            /// </summary>
            float m_BaseAngle;

            /// <summary>
            /// The target rotate we calculate the offset to
            /// </summary>
            float m_CurrentOffset;

            /// <summary>
            /// Any previous offsets we've added in
            /// </summary>
            float m_AccumulatedAngle;

            /// <summary>
            /// The total rotation that occurred from when this rotation started being tracked
            /// </summary>
            public float totalOffset => m_AccumulatedAngle + m_CurrentOffset;

            /// <summary>
            /// Resets the tracked rotation so that total offset returns 0
            /// </summary>
            public void Reset()
            {
                m_BaseAngle = 0.0f;
                m_CurrentOffset = 0.0f;
                m_AccumulatedAngle = 0.0f;
            }

            /// <summary>
            /// Sets a new anchor rotation while maintaining any previously accumulated offset
            /// </summary>
            /// <param name="direction">The XZ vector used to calculate a rotation angle</param>
            public void SetBaseFromVector(Vector3 direction)
            {
                // Update any accumulated angle
                m_AccumulatedAngle += m_CurrentOffset;

                // Now set a new base angle
                m_BaseAngle = Mathf.Atan2(direction.z, direction.x) * Mathf.Rad2Deg;
                m_CurrentOffset = 0.0f;
            }

            public void SetTargetFromVector(Vector3 direction)
            {
                // Set the target angle
                var targetAngle = Mathf.Atan2(direction.z, direction.x) * Mathf.Rad2Deg;

                // Return the offset
                m_CurrentOffset = ShortestAngleDistance(m_BaseAngle, targetAngle, 360.0f);

                // If the offset is greater than 90 degrees, we update the base so we can rotate beyond 180 degrees
                if (Mathf.Abs(m_CurrentOffset) > 90.0f)
                {
                    m_BaseAngle = targetAngle;
                    m_AccumulatedAngle += m_CurrentOffset;
                    m_CurrentOffset = 0.0f;
                }
            }
        }

        [Serializable]
        public class ValueChangeEvent : UnityEvent<float> { }

        [SerializeField]
        [Tooltip("The object that is visually grabbed and manipulated")]
        Transform m_Handle = null;

        [SerializeField]
        [Tooltip("The value of the knob")]
        [Range(0.0f, 1.0f)]
        float m_Value = 0.5f;

        [SerializeField]
        [Tooltip("Whether this knob's rotation should be clamped by the angle limits")]
        bool m_ClampedMotion = true;

        [SerializeField]
        [Tooltip("Rotation of the knob at value '1'")]
        float m_MaxAngle = 90.0f;

        [SerializeField]
        [Tooltip("Rotation of the knob at value '0'")]
        float m_MinAngle = -90.0f;

        [SerializeField]
        [Tooltip("Angle increments to support, if greater than '0'")]
        float m_AngleIncrement = 0.0f;

        [SerializeField]
        [Tooltip("The position of the interactor controls rotation when outside this radius")]
        float m_PositionTrackedRadius = 0.1f;

        [SerializeField]
        [Tooltip("How much controller rotation ")]
        float m_TwistSensitivity = 1.5f;

        [SerializeField]
        [Tooltip("Events to trigger when the knob is rotated")]
        ValueChangeEvent m_OnValueChange = new ValueChangeEvent();

        IXRSelectInteractor m_Interactor;

        bool m_PositionDriven = false;
        bool m_UpVectorDriven = false;

        TrackedRotation m_PositionAngles = new TrackedRotation();
        TrackedRotation m_UpVectorAngles = new TrackedRotation();
        TrackedRotation m_ForwardVectorAngles = new TrackedRotation();

        float m_BaseKnobRotation = 0.0f;

        /// <summary>
        /// The object that is visually grabbed and manipulated
        /// </summary>
        public Transform handle
        {
            get => m_Handle;
            set => m_Handle = value;
        }

        /// <summary>
        /// The value of the knob
        /// </summary>
        public float value
        {
            get => m_Value;
            set
            {
                SetValue(value);
                SetKnobRotation(ValueToRotation());
            }
        }

        /// <summary>
        /// Whether this knob's rotation should be clamped by the angle limits
        /// </summary>
        public bool clampedMotion
        {
            get => m_ClampedMotion;
            set => m_ClampedMotion = value;
        }

        /// <summary>
        /// Rotation of the knob at value '1'
        /// </summary>
        public float maxAngle
        {
            get => m_MaxAngle;
            set => m_MaxAngle = value;
        }

        /// <summary>
        /// Rotation of the knob at value '0'
        /// </summary>
        public float minAngle
        {
            get => m_MinAngle;
            set => m_MinAngle = value;
        }

        /// <summary>
        /// The position of the interactor controls rotation when outside this radius
        /// </summary>
        public float positionTrackedRadius
        {
            get => m_PositionTrackedRadius;
            set => m_PositionTrackedRadius = value;
        }

        /// <summary>
        /// Events to trigger when the knob is rotated
        /// </summary>
        public ValueChangeEvent onValueChange => m_OnValueChange;

        void Start()
        {
            SetValue(m_Value);
            SetKnobRotation(ValueToRotation());
        }

        protected override void OnEnable()
        {
            base.OnEnable();
            selectEntered.AddListener(StartGrab);
            selectExited.AddListener(EndGrab);
        }

        protected override void OnDisable()
        {
            selectEntered.RemoveListener(StartGrab);
            selectExited.RemoveListener(EndGrab);
            base.OnDisable();
        }

        void StartGrab(SelectEnterEventArgs args)
        {
            m_Interactor = args.interactorObject;

            m_PositionAngles.Reset();
            m_UpVectorAngles.Reset();
            m_ForwardVectorAngles.Reset();

            UpdateBaseKnobRotation();
            UpdateRotation(true);
        }

        void EndGrab(SelectExitEventArgs args)
        {
            m_Interactor = null;
        }

        public override void ProcessInteractable(XRInteractionUpdateOrder.UpdatePhase updatePhase)
        {
            base.ProcessInteractable(updatePhase);

            if (updatePhase == XRInteractionUpdateOrder.UpdatePhase.Dynamic)
            {
                if (isSelected)
                {
                    UpdateRotation();
                }
            }
        }

        void UpdateRotation(bool freshCheck = false)
        {
            // Are we in position offset or direction rotation mode?
            var interactorTransform = m_Interactor.GetAttachTransform(this);

            // We cache the three potential sources of rotation - the position offset, the forward vector of the controller, and up vector of the controller
            // We store any data used for determining which rotation to use, then flatten the vectors to the local xz plane
            var localOffset = transform.InverseTransformVector(interactorTransform.position - m_Handle.position);
            localOffset.y = 0.0f;
            var radiusOffset = transform.TransformVector(localOffset).magnitude;
            localOffset.Normalize();

            var localForward = transform.InverseTransformDirection(interactorTransform.forward);
            var localY = Math.Abs(localForward.y);
            localForward.y = 0.0f;
            localForward.Normalize();

            var localUp = transform.InverseTransformDirection(interactorTransform.up);
            localUp.y = 0.0f;
            localUp.Normalize();


            if (m_PositionDriven && !freshCheck)
                radiusOffset *= (1.0f + k_ModeSwitchDeadZone);

            // Determine when a certain source of rotation won't contribute - in that case we bake in the offset it has applied
            // and set a new anchor when they can contribute again
            if (radiusOffset >= m_PositionTrackedRadius)
            {
                if (!m_PositionDriven || freshCheck)
                {
                    m_PositionAngles.SetBaseFromVector(localOffset);
                    m_PositionDriven = true;
                }
            }
            else
                m_PositionDriven = false;

            // If it's not a fresh check, then we weight the local Y up or down to keep it from flickering back and forth at boundaries
            if (!freshCheck)
            {
                if (!m_UpVectorDriven)
                    localY *= (1.0f - (k_ModeSwitchDeadZone * 0.5f));
                else
                    localY *= (1.0f + (k_ModeSwitchDeadZone * 0.5f));
            }

            if (localY > 0.707f)
            {
                if (!m_UpVectorDriven || freshCheck)
                {
                    m_UpVectorAngles.SetBaseFromVector(localUp);
                    m_UpVectorDriven = true;
                }
            }
            else
            {
                if (m_UpVectorDriven || freshCheck)
                {
                    m_ForwardVectorAngles.SetBaseFromVector(localForward);
                    m_UpVectorDriven = false;
                }
            }

            // Get angle from position
            if (m_PositionDriven)
                m_PositionAngles.SetTargetFromVector(localOffset);

            if (m_UpVectorDriven)
                m_UpVectorAngles.SetTargetFromVector(localUp);
            else
                m_ForwardVectorAngles.SetTargetFromVector(localForward);

            // Apply offset to base knob rotation to get new knob rotation
            var knobRotation = m_BaseKnobRotation - ((m_UpVectorAngles.totalOffset + m_ForwardVectorAngles.totalOffset) * m_TwistSensitivity) - m_PositionAngles.totalOffset;

            // Clamp to range
            if (m_ClampedMotion)
                knobRotation = Mathf.Clamp(knobRotation, m_MinAngle, m_MaxAngle);

            SetKnobRotation(knobRotation);

            // Reverse to get value
            var knobValue = (knobRotation - m_MinAngle) / (m_MaxAngle - m_MinAngle);
            SetValue(knobValue);
        }

        void SetKnobRotation(float angle)
        {
            if (m_AngleIncrement > 0)
            {
                var normalizeAngle = angle - m_MinAngle;
                angle = (Mathf.Round(normalizeAngle / m_AngleIncrement) * m_AngleIncrement) + m_MinAngle;
            }

            if (m_Handle != null)
                m_Handle.localEulerAngles = new Vector3(0.0f, angle, 0.0f);
        }

        void SetValue(float value)
        {
            if (m_ClampedMotion)
                value = Mathf.Clamp01(value);

            if (m_AngleIncrement > 0)
            {
                var angleRange = m_MaxAngle - m_MinAngle;
                var angle = Mathf.Lerp(0.0f, angleRange, value);
                angle = Mathf.Round(angle / m_AngleIncrement) * m_AngleIncrement;
                value = Mathf.InverseLerp(0.0f, angleRange, angle);
            }

            m_Value = value;
            m_OnValueChange.Invoke(m_Value);
        }

        float ValueToRotation()
        {
            return m_ClampedMotion ? Mathf.Lerp(m_MinAngle, m_MaxAngle, m_Value) : Mathf.LerpUnclamped(m_MinAngle, m_MaxAngle, m_Value);
        }

        void UpdateBaseKnobRotation()
        {
            m_BaseKnobRotation = Mathf.LerpUnclamped(m_MinAngle, m_MaxAngle, m_Value);
        }

        static float ShortestAngleDistance(float start, float end, float max)
        {
            var angleDelta = end - start;
            var angleSign = Mathf.Sign(angleDelta);

            angleDelta = Math.Abs(angleDelta) % max;
            if (angleDelta > (max * 0.5f))
                angleDelta = -(max - angleDelta);

            return angleDelta * angleSign;
        }

        void OnDrawGizmosSelected()
        {
            const int k_CircleSegments = 16;
            const float k_SegmentRatio = 1.0f / k_CircleSegments;

            // Nothing to do if position radius is too small
            if (m_PositionTrackedRadius <= Mathf.Epsilon)
                return;

            // Draw a circle from the handle point at size of position tracked radius
            var circleCenter = transform.position;

            if (m_Handle != null)
                circleCenter = m_Handle.position;

            var circleX = transform.right;
            var circleY = transform.forward;

            Gizmos.color = Color.green;
            var segmentCounter = 0;
            while (segmentCounter < k_CircleSegments)
            {
                var startAngle = (float)segmentCounter * k_SegmentRatio * 2.0f * Mathf.PI;
                segmentCounter++;
                var endAngle = (float)segmentCounter * k_SegmentRatio * 2.0f * Mathf.PI;

                Gizmos.DrawLine(circleCenter + (Mathf.Cos(startAngle) * circleX + Mathf.Sin(startAngle) * circleY) * m_PositionTrackedRadius,
                    circleCenter + (Mathf.Cos(endAngle) * circleX + Mathf.Sin(endAngle) * circleY) * m_PositionTrackedRadius);
            }
        }

        void OnValidate()
        {
            if (m_ClampedMotion)
                m_Value = Mathf.Clamp01(m_Value);

            if (m_MinAngle > m_MaxAngle)
                m_MinAngle = m_MaxAngle;

            SetKnobRotation(ValueToRotation());
        }
    }
}            
          </code>
      </div>
    </div>
    <div class="w-full min-h-screen grid grid-cols-2 gap-x-8 mx-auto p-4 max-w-screen-xl py-12">
      <div class="grow sticky top-24 h-fit w-full">
        <h3 class="md:text-4xl leading-none customfont text-orange-600">l helicoptere</h3>
        <p class="mt-4">L'hélicoptère viendra vous récupérer une fois que vous aurez réussi toutes les énigmes pour vous échapper.</p>
        <img src="helicopter.png" alt="" class="rounded mt-2">
      </div>
      <div class="grow w-full">
        <pre>
          <code class="language-clike">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class HelicopterManager : MonoBehaviour
{
    public GameObject[] helices;
    public float rotationSpeed = 1500f;
    private bool moving = false;

    void Update()
    {
        if (helices != null && helices.Length > 0) {
            foreach(GameObject helice in helices) {
                helice.transform.Rotate(Vector3.up * rotationSpeed * Time.deltaTime);
            }
        }

        if (moving) {
            if (transform.position.z > 0) {
                transform.Translate(Vector3.forward * Time.deltaTime * 5f);
            }
        }
    }

    public void OnPushTrigger() {
        moving = true;
    }
}
          </code>
      </div>
    </div>
    </section>
    <section id="unity">
      <h3 class="md:text-4xl text-orange-600 leading-none customfont mb-4 text-center">unity</h3>
      <div class="w-full grid grid-cols-2 gap-x-8 mx-auto p-4 max-w-screen-xl py-12">
        <div>
          <p>Nous avons une structure de projet très classique avec des dossiers pour ranger les assets : scripts, prefabs, materials, fonts, scenes...</p>
        </div>
        <img src="structure.png" alt="" class="rounded">
      </div>
      <div class="w-full grid grid-cols-2 gap-x-8 mx-auto p-4 max-w-screen-xl py-12">
        <img src="unity-screen.png" alt="" class="rounded">
        <div>
          <p>Voici une capture d'écran de notre interface Unity</p>
        </div>
      </div>
    </section>
  </body>
</html>
